¬°Perfecto! Gracias por compartir tanto detalle. Hay **tres puntos cr√≠ticos** que est√°n causando que **no se asignen las cookies al navegador** y que **no aparezca el header `Authorization` en las peticiones**.

Vamos por partes, y luego te doy **soluciones claras** por tipo de cliente (web vs mobile).

---

## üß© Problema detectado

### 1. ‚ö†Ô∏è Cookies no se guardan en navegador (Web)
En tu backend est√°s haciendo esto:
```ts
res.cookie('accessToken', accessToken, {
  httpOnly: false,
  secure: false,
  maxAge: 60 * 60 * 1000,
  sameSite: 'lax',
});
```

**Pero en el frontend NO est√°s usando `credentials: 'include'` en el fetch o axios.**

üîß **Soluci√≥n**:
En el `useFetchPost` hook, necesitas agregar `withCredentials: true` en la config de Axios:

```ts
const config: AxiosRequestConfig = {
  method: 'POST',
  url,
  headers: {
    'Content-Type': 'application/json',
    ...headers,
  },
  data: body,
  withCredentials: true, // <-- esto habilita env√≠o/recepci√≥n de cookies
};
```

Y tambi√©n aseg√∫rate que tus requests GET, PUT, DELETE, etc. desde el frontend **tambi√©n tengan** `withCredentials: true`.

---

### 2. ‚ö†Ô∏è Token no est√° en headers (Mobile)
En `handleSignIn` haces esto:
```ts
if (result.data.accessToken && userResponse) {
  sessionStorage.setItem('accessToken', result.data.accessToken);
}
```

Pero **luego nunca usas este token** para enviarlo como header en peticiones posteriores.

üîß **Soluci√≥n**:
Cuando hagas peticiones desde mobile/web con `fetch` o `axios`, a√±ade manualmente el header:

```ts
headers: {
  'Authorization': `Bearer ${sessionStorage.getItem('accessToken')}`,
}
```

Puedes extender tu `useFetchPost` para hacer esto autom√°ticamente si detectas `accessToken` en sessionStorage.

---

### 3. üß† Cookies no se leen en el middleware
Tu middleware est√° bien escrito:

```ts
if (req.cookies.accessToken) {
```

Pero si no ves las cookies ah√≠, probablemente sea por:

- Falta de `withCredentials: true` en frontend ‚úÖ
- O falta de `cookieParser()` en el backend, lo cual **s√≠ tienes** ‚úÖ
- O no est√°s haciendo peticiones desde el mismo dominio/subdominio

---

## ‚úÖ Acciones recomendadas

### ‚úÖ Para el frontend:

1. En `axios` a√±ade `withCredentials: true` siempre que esperes cookies.
2. Si usas `accessToken` de sessionStorage (mobile), incl√∫yelo en headers:

```ts
headers: {
  'Authorization': `Bearer ${sessionStorage.getItem('accessToken')}`,
}
```

### ‚úÖ Para el backend:

1. Revisa configuraci√≥n de cookies:

```ts
res.cookie('accessToken', accessToken, {
  httpOnly: true, // mejor mantenerlo en true en producci√≥n
  secure: process.env.NODE_ENV === 'production',
  sameSite: 'Lax',
  maxAge: 1000 * 60 * 60,
});
```

2. Revisa configuraci√≥n CORS (**ya lo haces bien**):

```ts
app.use(cors({
  origin: 'http://localhost:5173',
  credentials: true,
}));
```

---

## üß™ Extra: ¬øC√≥mo detectar si el navegador acepta las cookies?

Puedes agregar un console.log de `document.cookie` en tu app web justo despu√©s de hacer login, para ver si se asign√≥:

```ts
console.log('Cookies actuales:', document.cookie);
```

---

## ‚úÖ Bonus: Middleware extendido (mejor pr√°ctica)

Tu middleware `getAuthToken` es bastante bueno. Puedes extenderlo as√≠:

```ts
export const getAuthToken = (req) => {
  const authHeader = req.headers['authorization'];
  if (authHeader?.startsWith('Bearer ')) {
    return authHeader.split(' ')[1];
  }
  if (req.cookies?.accessToken) {
    return req.cookies.accessToken;
  }
  return null;
};
```

---

## ¬øPr√≥ximo paso?

¬øQuieres que te cree una versi√≥n de `useFetchGet` que incluya autom√°ticamente el `accessToken` desde `sessionStorage`?  
¬øO prefieres que el backend devuelva *siempre* el `accessToken` tambi√©n para web en JSON adem√°s de cookie?

Ambos caminos son v√°lidos. ¬øQu√© prefieres?

¬°Buena pregunta! Para incluir `credentials` (espec√≠ficamente `withCredentials: true`) en tu petici√≥n `axios.get(...)`, simplemente debes pasar un segundo par√°metro a `axios.get`, que es un objeto de configuraci√≥n (`AxiosRequestConfig`).  

Actualmente en tu c√≥digo no est√°s pasando ese objeto (¬°hay un mont√≥n de comas vac√≠as ah√≠ üòÖ!), as√≠ que te muestro c√≥mo hacerlo bien:

---

### ‚úÖ Soluci√≥n: incluir `withCredentials` en `axios.get`

```ts
const fetchData = async (url: string) => {
  setIsLoading(true);
  setError(null);

  console.log('url:', url);

  try {
    const response: AxiosResponse<R> = await axios.get(url, {
      withCredentials: true, // üëà Esta es la clave para que se env√≠en las cookies
      headers: {
        // opcional: agrega token desde sessionStorage si es necesario (para mobile)
        ...(sessionStorage.getItem('accessToken') && {
          Authorization: `Bearer ${sessionStorage.getItem('accessToken')}`,
        }),
      },
    });

    if (response.status >= 200 && response.status < 300) {
      const respData = response.data as { data: R; message: string };
      console.log('üöÄ ~ fetchData ~ respData:', respData);

      setData(respData.data);
      setMessage(respData.message);
    } else {
      const errMsg = `Unexpected status code: ${response.status}`;
      console.log('from useFetch:', errMsg);
      throw new Error(errMsg);
    }
  } catch (err: unknown) {
    let errorMessage = 'Unexpected error occurred';

    if (axios.isAxiosError(err)) {
      errorMessage = err.response?.data?.message || err.message;
    } else if (err instanceof Error) {
      errorMessage = err.message;
    }

    console.error('Error:', errorMessage);
    setData(null);
    setError(errorMessage);
  } finally {
    setIsLoading(false);
  }
};
```

---

### üß™ ¬øQu√© hace `withCredentials`?

- En **web**, permite que el navegador **env√≠e autom√°ticamente cookies** (`accessToken`, `refreshToken`) al backend.
- Es necesario que el backend tenga:
  ```js
  app.use(cors({
    origin: 'http://localhost:5173',
    credentials: true
  }));
  ```

---

¬øQuieres que hagamos un peque√±o helper para que use el token si es mobile y cookies si es web, autom√°ticamente?